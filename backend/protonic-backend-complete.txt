# PROTONIC FITNESS - COMPLETE BACKEND PACKAGE

## 📦 FOLDER STRUCTURE

```
protonic-backend/
├── src/
│   ├── db/
│   │   └── index.ts
│   ├── middleware/
│   │   └── auth.ts
│   ├── routes/
│   │   └── auth.routes.ts
│   ├── services/
│   │   ├── tokens.ts
│   │   └── email.ts
│   ├── utils/
│   │   ├── http.ts
│   │   ├── jwt.ts
│   │   └── password.ts
│   └── server.ts
├── .env
├── .env.example
├── .gitignore
├── package.json
├── tsconfig.json
├── database-schema.sql
└── README.md
```

---

## 📄 FILE: package.json

```json
{
  "name": "protonic-fitness-backend",
  "version": "1.0.0",
  "description": "Backend API for Protonic Fitness",
  "main": "dist/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.3",
    "bcrypt": "^5.1.1",
    "jsonwebtoken": "^9.0.2",
    "express-validator": "^7.0.1",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "morgan": "^1.10.0",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/pg": "^8.10.9",
    "@types/bcrypt": "^5.0.2",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/cors": "^2.8.17",
    "@types/morgan": "^1.9.9",
    "typescript": "^5.3.3",
    "ts-node-dev": "^2.0.0"
  }
}
```

---

## 📄 FILE: tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

---

## 📄 FILE: .env.example

```env
# Server Configuration
PORT=4000
NODE_ENV=development

# Database
# Get this from Supabase: Settings → Database → Connection String (URI)
DATABASE_URL=postgresql://postgres.YOUR_PROJECT_ID:YOUR_PASSWORD@aws-0-us-east-1.pooler.supabase.com:6543/postgres

# JWT Secrets (Generate random strings for production!)
JWT_ACCESS_SECRET=change_this_to_a_long_random_string_for_access_tokens
JWT_REFRESH_SECRET=change_this_to_a_long_random_string_for_refresh_tokens
JWT_RESET_SECRET=change_this_to_a_long_random_string_for_reset_tokens

# Token Expiration
JWT_ACCESS_TTL=15m
JWT_REFRESH_TTL=30d
JWT_RESET_TTL=15m

# Frontend URL
FRONTEND_URL=http://localhost:3000

# Email
EMAIL_FROM="Protonic Fitness <no-reply@protonic.fit>"
```

---

## 📄 FILE: .gitignore

```
node_modules/
dist/
.env
*.log
.DS_Store
```

---

## 📄 FILE: src/db/index.ts

```typescript
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 10,
  idleTimeoutMillis: 30_000,
  connectionTimeoutMillis: 10_000,
});

pool.on('error', (err) => {
  console.error('Unexpected database error:', err);
  process.exit(-1);
});

export default pool;
```

---

## 📄 FILE: src/utils/password.ts

```typescript
import bcrypt from 'bcrypt';

const ROUNDS = 12;

export const hashPassword = async (plain: string) => {
  const salt = await bcrypt.genSalt(ROUNDS);
  return bcrypt.hash(plain, salt);
};

export const comparePassword = (plain: string, hash: string) =>
  bcrypt.compare(plain, hash);
```

---

## 📄 FILE: src/utils/http.ts

```typescript
import { NextFunction, Request, Response } from 'express';

export const asyncHandler = (fn: Function) =>
  (req: Request, res: Response, next: NextFunction) =>
    Promise.resolve(fn(req, res, next)).catch(next);
```

---

## 📄 FILE: src/utils/jwt.ts

```typescript
import jwt from 'jsonwebtoken';

type JWTPayload = Record<string, any>;

export const signJwt = (payload: JWTPayload, secret: string, expiresIn: string) =>
  jwt.sign(payload, secret, { expiresIn });

export const verifyJwt = (token: string, secret: string) =>
  jwt.verify(token, secret) as JWTPayload;
```

---

## 📄 FILE: src/middleware/auth.ts

```typescript
import { Request, Response, NextFunction } from 'express';
import { verifyJwt } from '../utils/jwt';

declare global {
  namespace Express {
    interface Request {
      user?: { id: string; email: string; [k: string]: any };
    }
  }
}

export const requireAuth = (req: Request, res: Response, next: NextFunction) => {
  const header = req.headers.authorization;
  
  if (!header?.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing or invalid Authorization header' });
  }
  
  const token = header.slice(7);
  
  try {
    const payload = verifyJwt(token, process.env.JWT_ACCESS_SECRET!);
    req.user = { id: payload.sub, email: payload.email };
    return next();
  } catch {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
};
```

---

## 📄 FILE: src/services/tokens.ts

```typescript
import pool from '../db';
import { signJwt, verifyJwt } from '../utils/jwt';

export const createAccessToken = (user: { id: string; email: string }) =>
  signJwt(
    { sub: user.id, email: user.email, type: 'access' },
    process.env.JWT_ACCESS_SECRET!,
    process.env.JWT_ACCESS_TTL || '15m'
  );

export const createRefreshToken = (user: { id: string; email: string }) =>
  signJwt(
    { sub: user.id, email: user.email, type: 'refresh' },
    process.env.JWT_REFRESH_SECRET!,
    process.env.JWT_REFRESH_TTL || '30d'
  );

export const createPasswordResetToken = (user: { id: string; email: string }) =>
  signJwt(
    { sub: user.id, email: user.email, type: 'password_reset' },
    process.env.JWT_RESET_SECRET!,
    process.env.JWT_RESET_TTL || '15m'
  );

export const storeRefreshToken = async (userId: string, token: string, expiresAt: Date) => {
  await pool.query(
    `INSERT INTO refresh_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)`,
    [userId, token, expiresAt]
  );
};

export const revokeRefreshToken = async (token: string) => {
  await pool.query(`DELETE FROM refresh_tokens WHERE token = $1`, [token]);
};

export const isRefreshTokenValid = async (token: string) => {
  const { rows } = await pool.query(
    `SELECT user_id, expires_at FROM refresh_tokens WHERE token = $1`,
    [token]
  );
  if (rows.length === 0) return null;
  const row = rows[0];
  if (new Date(row.expires_at) < new Date()) return null;
  return row.user_id as string;
};

export const parseRefreshExp = (token: string) => {
  const payload = verifyJwt(token, process.env.JWT_REFRESH_SECRET!);
  return new Date((payload as any).exp * 1000);
};
```

---

## 📄 FILE: src/services/email.ts

```typescript
export const sendPasswordResetEmail = async (to: string, token: string) => {
  const link = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password?token=${encodeURIComponent(token)}`;
  
  console.log(`
═══════════════════════════════════════════
📧 PASSWORD RESET EMAIL
═══════════════════════════════════════════
To: ${to}
Link: ${link}
Expires: 15 minutes
═══════════════════════════════════════════
  `);
  
  return { ok: true };
};
```

---

## 📄 FILE: src/routes/auth.routes.ts

```typescript
import { Router } from 'express';
import { body, validationResult } from 'express-validator';
import pool from '../db';
import { asyncHandler } from '../utils/http';
import { hashPassword, comparePassword } from '../utils/password';
import { requireAuth } from '../middleware/auth';
import {
  createAccessToken,
  createRefreshToken,
  storeRefreshToken,
  revokeRefreshToken,
  isRefreshTokenValid,
  parseRefreshExp,
  createPasswordResetToken,
} from '../services/tokens';
import { sendPasswordResetEmail } from '../services/email';
import jwt from 'jsonwebtoken';

const router = Router();

/* -------------------------------- Register -------------------------------- */
router.post(
  '/register',
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 8 }),
  body('name').optional().isString().isLength({ max: 255 }),
  asyncHandler(async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(422).json({ errors: errors.array() });

    const { email, password, name } = req.body;

    const { rows: existing } = await pool.query(`SELECT 1 FROM users WHERE email = $1`, [email]);
    if (existing.length) return res.status(409).json({ error: 'Email already in use' });

    const password_hash = await hashPassword(password);

    const { rows } = await pool.query(
      `INSERT INTO users (email, password_hash, is_active, email_verified)
       VALUES ($1, $2, true, false)
       RETURNING id, email, email_verified`,
      [email, password_hash]
    );
    const user = rows[0];

    if (name) {
      await pool.query(`INSERT INTO user_profiles (user_id, name) VALUES ($1, $2)`, [user.id, name]);
    }
    await pool.query(`INSERT INTO user_stats (user_id) VALUES ($1)`, [user.id]);

    return res.status(201).json({ user: { id: user.id, email: user.email, email_verified: user.email_verified } });
  })
);

/* --------------------------------- Login ---------------------------------- */
router.post(
  '/login',
  body('email').isEmail().normalizeEmail(),
  body('password').isString().isLength({ min: 8 }),
  asyncHandler(async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(422).json({ errors: errors.array() });

    const { email, password } = req.body;

    const { rows } = await pool.query(
      `SELECT id, email, password_hash, is_active FROM users WHERE email = $1`,
      [email]
    );
    if (!rows.length) return res.status(401).json({ error: 'Invalid email or password' });

    const user = rows[0];
    if (!user.is_active) return res.status(403).json({ error: 'Account disabled' });

    const ok = await comparePassword(password, user.password_hash);
    if (!ok) return res.status(401).json({ error: 'Invalid email or password' });

    await pool.query(`UPDATE users SET last_login = NOW() WHERE id = $1`, [user.id]);

    const accessToken = createAccessToken({ id: user.id, email: user.email });
    const refreshToken = createRefreshToken({ id: user.id, email: user.email });

    const expiresAt = parseRefreshExp(refreshToken);
    await storeRefreshToken(user.id, refreshToken, expiresAt);

    return res.status(200).json({ accessToken, refreshToken });
  })
);

/* -------------------------------- Refresh --------------------------------- */
router.post(
  '/refresh',
  body('refreshToken').isString(),
  asyncHandler(async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(422).json({ errors: errors.array() });

    const { refreshToken } = req.body;
    const userId = await isRefreshTokenValid(refreshToken);
    if (!userId) return res.status(401).json({ error: 'Invalid refresh token' });

    let payload: any;
    try {
      payload = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET!);
    } catch {
      await revokeRefreshToken(refreshToken);
      return res.status(401).json({ error: 'Invalid refresh token' });
    }

    await revokeRefreshToken(refreshToken);

    const user = { id: payload.sub as string, email: payload.email as string };
    const newAccess = createAccessToken(user);
    const newRefresh = createRefreshToken(user);
    const expiresAt = parseRefreshExp(newRefresh);
    await storeRefreshToken(user.id, newRefresh, expiresAt);

    return res.status(200).json({ accessToken: newAccess, refreshToken: newRefresh });
  })
);

/* --------------------------------- Logout --------------------------------- */
router.post(
  '/logout',
  body('refreshToken').isString(),
  asyncHandler(async (req, res) => {
    const { refreshToken } = req.body;
    await revokeRefreshToken(refreshToken);
    return res.status(200).json({ ok: true });
  })
);

/* ---------------------------- Forgot Password ----------------------------- */
router.post(
  '/forgot-password',
  body('email').isEmail().normalizeEmail(),
  asyncHandler(async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(422).json({ errors: errors.array() });

    const { email } = req.body;
    const { rows } = await pool.query(`SELECT id, email FROM users WHERE email = $1`, [email]);

    if (!rows.length) return res.status(200).json({ ok: true });

    const user = rows[0];
    const token = createPasswordResetToken({ id: user.id, email: user.email });
    await sendPasswordResetEmail(user.email, token);
    return res.status(200).json({ ok: true });
  })
);

/* ----------------------------- Reset Password ----------------------------- */
router.post(
  '/reset-password',
  body('token').isString(),
  body('newPassword').isLength({ min: 8 }),
  asyncHandler(async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) return res.status(422).json({ errors: errors.array() });

    const { token, newPassword } = req.body;

    let payload: any;
    try {
      payload = jwt.verify(token, process.env.JWT_RESET_SECRET!);
      if (payload.type !== 'password_reset') throw new Error('Invalid token type');
    } catch {
      return res.status(400).json({ error: 'Invalid or expired token' });
    }

    const newHash = await hashPassword(newPassword);
    await pool.query(`UPDATE users SET password_hash = $1, updated_at = NOW() WHERE id = $2`, [
      newHash,
      payload.sub,
    ]);

    await pool.query(`DELETE FROM refresh_tokens WHERE user_id = $1`, [payload.sub]);

    return res.status(200).json({ ok: true });
  })
);

/* ----------------------------------- Me ----------------------------------- */
router.get(
  '/me',
  requireAuth,
  asyncHandler(async (req, res) => {
    const { rows } = await pool.query(
      `SELECT id, email, is_active, email_verified, created_at, updated_at
       FROM users WHERE id = $1`,
      [req.user!.id]
    );
    if (!rows.length) return res.status(404).json({ error: 'User not found' });
    return res.status(200).json({ user: rows[0] });
  })
);

export default router;
```

---

## 📄 FILE: src/server.ts

```typescript
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import morgan from 'morgan';
import authRoutes from './routes/auth.routes';

const app = express();

// Security & utilities
app.use(helmet());
app.use(cors({ origin: true, credentials: true }));
app.use(express.json({ limit: '1mb' }));
app.use(morgan(process.env.NODE_ENV === 'production' ? 'combined' : 'dev'));

// Rate limiting
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  limit: 150,
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/auth', authLimiter);

// Routes
app.use('/auth', authRoutes);

// Health check
app.get('/health', (_req, res) => res.json({ ok: true }));

// Error handler
app.use((err: any, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
  if (process.env.NODE_ENV !== 'production') console.error(err);
  const status = err.status || 500;
  res.status(status).json({ error: err.message || 'Internal Server Error' });
});

// Start server
const port = process.env.PORT || 4000;
app.listen(port, () => {
  console.log(`
🚀 Protonic Backend Server Running!
📡 Environment: ${process.env.NODE_ENV || 'development'}
🔗 Server: http://localhost:${port}
💚 Health: http://localhost:${port}/health
🔐 Auth API: http://localhost:${port}/auth
  `);
});
```

---

## 📄 FILE: database-schema.sql

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP
);

-- User profiles
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    avatar_url TEXT,
    date_of_birth DATE,
    gender VARCHAR(20),
    height_cm INTEGER,
    weight_kg DECIMAL(5,2),
    fitness_level VARCHAR(50),
    goals TEXT[],
    bio TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Subscriptions
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    plan_type VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL,
    stripe_customer_id VARCHAR(255),
    stripe_subscription_id VARCHAR(255),
    current_period_start TIMESTAMP,
    current_period_end TIMESTAMP,
    trial_end TIMESTAMP,
    cancel_at_period_end BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Refresh tokens
CREATE TABLE refresh_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token TEXT NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User stats
CREATE TABLE user_stats (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    level INTEGER DEFAULT 1,
    xp INTEGER DEFAULT 0,
    total_workouts INTEGER DEFAULT 0,
    total_workout_minutes INTEGER DEFAULT 0,
    total_calories_burned INTEGER DEFAULT 0,
    current_streak INTEGER DEFAULT 0,
    longest_streak INTEGER DEFAULT 0,
    last_workout_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_user_profiles_user_id ON user_profiles(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);

-- Auto-update trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_profiles_updated_at BEFORE UPDATE ON user_profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON subscriptions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_stats_updated_at BEFORE UPDATE ON user_stats
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

---

## 📄 FILE: README.md

```markdown
# Protonic Fitness Backend

Production-ready backend API for Protonic Fitness application.

## 🚀 Quick Setup

### 1. Install Dependencies

```bash
npm install
```

### 2. Set Up Environment Variables

Copy `.env.example` to `.env`:

```bash
cp .env.example .env
```

Then edit `.env` and fill in:
- `DATABASE_URL` - Your Supabase connection string
- `JWT_ACCESS_SECRET` - Random secret string
- `JWT_REFRESH_SECRET` - Different random secret string
- `JWT_RESET_SECRET` - Another different random secret string

### 3. Set Up Database

1. Go to Supabase SQL Editor
2. Copy contents of `database-schema.sql`
3. Paste and run in SQL Editor

### 4. Start Development Server

```bash
npm run dev
```

Server will start on http://localhost:4000

## 🧪 Test the API

### Register User
```bash
curl -X POST http://localhost:4000/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123",
    "name": "Test User"
  }'
```

### Login
```bash
curl -X POST http://localhost:4000/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'
```

### Get Current User (Protected Route)
```bash
curl http://localhost:4000/auth/me \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

## 📚 API Endpoints

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| POST | /auth/register | No | Register new user |
| POST | /auth/login | No | Login user |
| POST | /auth/refresh | No | Refresh access token |
| POST | /auth/logout | No | Logout user |
| POST | /auth/forgot-password | No | Request password reset |
| POST | /auth/reset-password | No | Reset password |
| GET | /auth/me | Yes | Get current user |
| GET | /health | No | Health check |

## 🔧 Scripts

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm start` - Start production server

## 🌍 Environment Variables

See `.env.example` for all required environment variables.

## 📦 Tech Stack

- Node.js + Express
- TypeScript
- PostgreSQL (Supabase)
- JWT Authentication
- bcrypt for password hashing

## 🔐 Security Features

- Helmet.js for security headers
- Rate limiting
- JWT token rotation
- Password hashing with bcrypt
- SQL injection protection
- CORS configuration
```

---

## 🎯 SETUP INSTRUCTIONS

### Step 1: Create Folder & Copy Files

1. Create a folder called `protonic-backend` on your computer
2. Copy each file above into the correct location following the folder structure

### Step 2: Open Terminal in That Folder

```bash
cd protonic-backend
```

### Step 3: Install Dependencies

```bash
npm install
```

### Step 4: Create .env File

1. Copy `.env.example` to `.env`
2. Update `DATABASE_URL` with:
   ```
   postgresql://postgres.qlscjsvliwrerdpuwxev:YOUR_PASSWORD@aws-0-us-east-1.pooler.supabase.com:6543/postgres
   ```
   Replace `YOUR_PASSWORD` with your actual Supabase password

### Step 5: Run Database Schema

1. Go to Supabase → SQL Editor
2. Copy `database-schema.sql` content
3. Paste and run

### Step 6: Start Server

```bash
npm run dev
```

---

## ✅ YOU NOW HAVE A COMPLETE BACKEND!

Everything is organized and ready to use!